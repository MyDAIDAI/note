# `HTTP`缓存

**缓存**是一种保存资源副本并在下次请求时直接使用该副本的技术。当`web`缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器下载

缓存的种类：
- 私有缓存: 只能用于单独用户
- 共享缓存：能够被多个用户使用

## （私有）浏览器缓存
私有缓存只能用户单独 用户。浏览器缓存拥有用户通过`HTTP`下载的所有文档。这个缓存为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余的请求

## (共享)代理缓存
共享缓存可以被多个用户使用。例如，`ISP`或公司可能会架设一个`web`代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复使用，减少网络拥堵与延迟

## 缓存操作的目标
常见的`HTTP`缓存只能存储`GET`响应，对于其他类型的响应无能为力。缓存的关键主要包括`request method`和目标`URI`

## 缓存控制
`HTTP`定义的`Cache-Control`头用来区分对缓存机制的支持情况，请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略
- 禁止进行缓存 `Cache-Control: no-store` : 缓存中不能存储任何关于客户端请求和服务端响应的内容，每次由客户端发起的请求都会下载完成的响应内容
- 强制确认缓存 `Cache-Control: no-cache` : 此方式下，每次有请求发出，缓存会将此请求发到服务器（带有与本地缓存相关的验证字段），服务器端会验证请求中的所描述的缓存是否过期，若未过期（状态码`304`）则缓存才使用本地缓存副本
- 过期资源验证 `Cache-Control: must-revalidate` : 此方式下，在本例缓存副本过期前使用本地副本，本地副本过期，则向服务器发生验证，若服务器返回状态码为`304`，则直接使用缓存的本地副本
- 私有缓存 `Cache-Control: private` : 该响应式专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中
- 公有缓存 `Cache-Control: public` : 该响应可以被任何中间人（代理，`CDN`）缓存，若指定为`public`,则一些通常不被中间人缓存的界面（带有验证信息等）将会被缓存
- `Pragma`头 : 请求中包含`Pragma`的效果跟在头信息中定义`Cache-Control: no-cache`相同，但`HTTP`响应头没有明确定义这个属性，所以它不能拿来完全代替`Cache-Control`头, 通常定义`Pragma`以向后兼容基于`HTTP/1.0`的客户端
## 缓存过期机制
过期机制中，最重要的指令是`max-age=<seconds>`，表示资源能够被缓存的最大时间，

## 新鲜度
理论上讲，当一个资源被缓存存储后，该资源应该可以被永久存储在缓存中。由于缓存只有有限的空间用于存储资源副本，所有缓存会定期将一些副本删除，这个过程叫做缓存驱逐。
另一方面，当服务器上面的资源进行了更新，那么缓存中的对应资源也应该被更新，由于`HTTP`是`C/S`模式的协议，服务器更新一个资源时，不可能直接通知客户端更新缓存，
所以双方必须为该资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是新鲜的，当过了过期时间后，该资源变为陈旧的。驱逐算法用于将陈旧资源替换为新鲜的（
一个陈旧的资源是不会直接被清除或者忽略的）当客户端发起一个请求时，缓存检索到已有的一个对应的陈旧资源，则缓存会先将此请求附加一个`If-None-Match`头，然后发给
目标服务器，以此来检查该资源副本是否是依然新鲜的，若服务器返回`304`，则表示此资源副本是新鲜的，若服务器通过`If-None-Match`或`If-Modified-Since`判断发现已过去，
那么会带有该资源的实体内容返回

![`HTTP`缓存处理过程](./images/cache.jpg)

可以计算缓存有效期的头部（优先级从高到低）
- `max-age`
- `expires`
- `last-modified`

## 为资源添加版本号
使用了缓存技术后，网站的响应效率和性能会得到极大的提升，为了优化缓存，可以将缓存的过期时间设置的尽量长，但是一旦我们需要更新资源的时候，
不能等待过期时间到了之后自动更新，而是希望尽快更新为最新的资源

`web`开发者解决这个问题的办法是在请求的`URL`之后添加版本号（也可以是任何防止缓存碰撞的标记例如hash或者时间戳），当版本号更新，意味着资源也就更新了，缓存也会进行更新

// TODO: 缓存验证

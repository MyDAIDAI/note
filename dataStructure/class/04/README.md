## 实现二叉树的先序、中序、后序遍历
- 思路：
    - 遍历顺序：
        - 先序：根-左-右
        - 中序：左-根-右
        - 后序：左-右-根
    - 递归方式：递归方式对二叉树的访问过程都是相同的，都是先访问根，再访问左子树，然后访问右子树，只是节点的打印顺序不同
    - 非递归方式：使用栈作为辅助空间
        - 先序遍历：
            - 开始将头节点压入栈中，然后判断栈中是否有值，有值就弹出，打印，
            - 并判断右子树是否存在，存在则放入栈中，然后判断左子树是否存在，存在则放入栈中。
            - 由于栈的取出过程是逆序的，所以后面会先弹出左子树的节点
        - 中序遍历：
            - 开始判断头节点head是否为空，不为空则将其压入栈中，并将其赋值为其的左子树
            - 如果当前节点的左子树一直存在，则一直将其左子树压入栈中
            - 当前节点的左子树不存在，则head为null, 然后从栈中取出数据，打印（左null 根head）
            - 打印之后拿到当前节点的右子树，继续将其左边所有节点放入栈中，直到左节点为null 之后打印当前节点，重复这个过程，直到head为null或者栈为空
        - 后序遍历：
            - 由于在递归中，后序遍历打印时机是在第三次回到该节点时，而栈的访问过程只有两次，
            - 所以可以使用**根右左**的访问顺序，然后将其值存储在另一个栈中，最后依次弹出栈中的数据
- code: [Code_01_PreInPostTraversal.js](Code_01_PreInPostTraversal.js)

## 在二叉树中找到一个节点的后继节点
- 题目：现在右一种新的二叉树节点类型如下，该结构比普通二叉树结构多了一个指向父节点的parent指针，假设有一颗Node类型的节点组成的二叉树，树中的每个节点的parent指针都正确的指向自己的父节点，头节点的parent指向Null, 只给一个在二叉树中的某个节点Node, 请实现返回Node的后继节点的函数。在二叉树的中序遍历的序列中，node的下一个节点叫做node的后继节点
    ```js
      class Node{
        constructor(value) {
          this.value = value
          this.left = null
          this.right = null
          this.parent = null
        }
      }
    ```
- 思路：
    - 中序遍历序列： （左子树）根（右子树） -> 左根右
    - 根据上面的遍历序列，可以将其分为下面两种类型
    - 当前节点有右节点，那么将当前节点作为**根**，后继节点就为其右子树中最左侧的节点
    - 当前节点没有右节点，那么将其做为一个根节点左子树中最右侧的节点，后继节点就为把当前节点作为左子树的第一个节点
    - 当前节点没有右节点，也没有将其作为左子树的节点，那么其后继节点为 null
- code: [Code_02_SuccessorNode.js](Code_02_SuccessorNode.js)

## 二叉树的序列化与反序列化
- 题目：使用不同的遍历方式将二叉树序列化以及反序列化
- 思路：
    - 前序遍历：前序遍历一棵树，将其遇到的节点转换为`value_`的形式，当节点为null时，转换为`#_`, 然后再使用前序遍历将字符串转换为树
    
    
## 判断一颗树是否是平衡二叉树
- 思路：
    - 平衡二叉树：左右子树的高度差不大于1
    - 使用递归，依次拿到当前节点的左子树的高度与右子树的高度
    - 判断左子树的高度与右子树的高度是否大于1
    - 大于1则不是平衡二叉树
- code: [Code_04_IsBalancedTree.js](Code_04_IsBalancedTree.js)


## 判断一个树是否是搜索二叉树
- 思路：
    - 搜索二叉树：左子树都比当前节点小，右子树都比当前节点大
    - 使用中序遍历进行比较，是一个升序的序列
- code: [Code_05_IsBSTAndCBT.js](Code_05_IsBSTAndCBT.js)
## 判断一个树是否是完全二叉树
- 思路：
    - 完全二叉树：一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树
    - 使用层次遍历
        - 一个节点有右子树，没有左子树，则不是完全二叉树
        - 一个节点没有右子树，则后面的节点没有子节点(后面的节点必须都是叶节点)，否则不是
- code: [Code_05_IsBSTAndCBT.js](Code_05_IsBSTAndCBT.js)

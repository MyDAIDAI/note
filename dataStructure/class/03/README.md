## 基本概念
- 栈：后入先出
- 队列：先入先出
- 哈希函数：
    - 输入长度可以无穷大但有限，输出长度固定
    - 不是随机函数，对于相同的输入内容会返回相同的输出值
    - 离散性
    - `set`与`map`
    - 操作时间复杂度 O(1)

---------------------------------------下面是一些算法题--------------------------------------

## 使用数组模拟一个大小固定的队列以及栈
- 栈的实现
    - 栈只是一个逻辑结构，可以用数组或者链表来实现
    - 思路
        1. 使用一个索引`index`来保存位置，`index`表示的是下一个数据要存储的位置
        2. 当向栈里面`push`元素的时候, 检测栈是否满，然后保存在`index`位置，`index++`
        3. 当向栈里面`pop`元素的时候，检测栈是否空，然后`index--`，并且弹出当前`index`位置的值
- 队列的实现
    - 队列只是一个逻辑结构，可以用数组或者链表来实现
    - 队列由于是从尾部进入，从头部出，实现会比栈复杂
    - 思路
        1. 使用一个变量`end`代表当前队列的尾部，在该索引位置`push`数据
        2. 使用一个变量`start`代表当前队列的头部，在该索引位置`poll`数据
        3. 当向队列里面`end`元素的时候，判断队列是否满，然后将数据保存在`end`位置, `end++`, 判断当前`end`的值是否等于`size`, 等于则将该索引赋值为0
        4. 当从队列向外面`poll`元素的时候，取出`start`位置的值，并将`start++`，判断当前`end`的值是否等于`size`, 等于则赋值为`0`
    - 注意：头部索引`start`与尾部索引`end`不相互依赖，互相独立，根据`size`来进行相互制约（相当于`start`一直在追`end`）
- code: [Code_01_ArrayToStackQueue.js](Code_01_ArrayToStackQueue.js)
## 实现一个特殊的栈
- 描述：在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。
- 要求：
    - po、push、getMin操作的时间复杂度都是O(1)。
    - 设计的栈类型可以使用现成的栈结构。
- 思路
    1. 有对时间复杂度的要求，那就用空间换取时间，创建两个栈
    2. 一个栈为`dataStack`数据栈，一个栈为`minStack`最小值栈
    3. 当`dataStack`与`minStack`都为空时，直接向里面`push`值
    4. 再次向`dataStack`里面`push`值的时候，拿出`minStack`顶部的值与要`push`的值比较，将其中较小的值推入
    5. 当`pop`数据的时候，`dataStack`与`minStack`同时`pop`
- 注意：要保持`dataStack`与`minStack`的同步
- code: [Code_02_GetMinStack.js](Code_02_GetMinStack.js)

## 如何仅用队列结构实现栈结构
- 思路：使用两个队列？
    1. 使用两个队列，一个数据队列，一个辅助队列
    2. 每次`push`数据的时候，保存到数据队列中
    3. 每次`pop`数据的时候，将数据队列中的值`push`到辅助队列中，剩下数据队列最后一个弹出
    4. 交换**数据队列**与**辅助队列**
## 如何仅用栈结构实现队列结构
- 思路: 使用两个栈?
    1. 使用两个栈，一个`push`栈，一个`pop`栈
    2. `push`数据的时候，向`push`栈中添加数据
    3. `poll`数据的时候，如果`pop`栈有数据则直接弹出返回，如果没有则将`push`栈中的数据**全部**放入到`pop`栈中，并从`pop`栈中弹出第一个数据
- 注意
    - 当`pop`栈不为空的时候不能向`pop`栈中添加数据
    - 每次从`push`栈向`pop`栈放数据的时候必须**全部**放完

- code: [Code_03_TwoQueueStack.js](Code_03_TwoQueueStack.js)
## 转圈打印矩阵
- 题目：给定一个整型矩阵matrix，请按照转圈的方式打印它。
    ```
    例如： 1 2 3 4 
           5 6 7 8 
           9 10 11 12 
           13 14 15 16 
        打印结果为：1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10
    ```
- 要求：额外空间复杂度为O(1)。
- 思路：
    - 打印一个矩阵边界上的数，拿到矩阵对角线上的两个坐标`[row1, col1]、[row2, col2]`
    - 当打印一行的时候，移动列坐标，当打印一列的时候，移动行坐标
    - 打印完成外圈矩阵之后，将`[row1, col1]`加1， 将`[row2, col2]`减1
    - 当`row1` > `row2`以及`col1` > `col2`时停止打印
    
## "之"字形打印矩阵
- 题目：给定一个矩阵matrix， 按照“之” 字形的方式打印这
     个矩阵， 例如： 1 2 3 4 5 6 7 8 9 10 11 12
     “之” 字形打印的结果为： 1， 2， 5， 9， 6， 3， 4， 7， 10， 11，
     8， 12
- 要求：额外空间复杂度为
- code: [Code_04_PrintMatrixSpiralOrder.js](Code_04_PrintMatrixSpiralOrder.js)

## 在行列都排好序的矩阵中找数
- 题目：给定一个有N*M的整型矩阵matrix和一个整数K，
     matrix的每一行和每一 列都是排好序的。实现一个函数，判断K
     是否在matrix中。 例如： 0 1 2 5 2 3 4 7 4
     4 4 8 5 7 7 9 如果K为7，返回true；如果K为6，返
     回false。
- 要求：时间复杂度为O(N+M)，额外空间复杂度为O(1)
- 思路：
    - 将右上角的点`(row, col)`作为基准值
    - 用基准值`matrix[row][col]`与传入值`num`进行比较
    - 基准值大于`num`，则`col--`
    - 基准值小于`num`, 则`row++`
    - 直到判断到`row === endRow`以及`col === 0`
- code: [Code_05_FindNumInSortedMatrix.js](Code_05_FindNumInSortedMatrix.js)

## 打印两个有序链表的公共部分
- 题目：给定两个有序链表的头指针head1和head2，打印两个链表的公共部分
- 思路：
    - 为第一个有序链表`head1`创建一个指针`index1`
    - 为第二个有序链表`head2`创建一个指针`index2`
    - 比较当前两个指针所指向的节点的值，值较小的指针向后移动
    - 当两个指针所指向的节点值相同时，同时移动并打印
    - 当其中的某个链表遍历完成或者两个同时遍历完成结束
- code: [Code_06_PrintCommonPart.js](Code_06_PrintCommonPart.js)

## 判断一个链表是否是回文结构
- 题目：给定一个链表的头节点head，请判断该链表是否为回文结构。 例如： 1->2->1，返回true。 1->2->2->1，返回true。15->6->15，返回true。 1->2->3，返回false。
- 思路：
    1. 方法1
        - 遍历链表并且使用一个栈将数据存储起来（栈弹出顺序为倒序）
        - 再次遍历链表，与栈中弹出的数据进行比较，如果都一样，则是回文结构
        - 时间复杂度O(n), 空间复杂度O(n)
    2. 方法2
        - 使用一个快指针，一个慢指针来遍历链表，当快指针遍历完成的时候，慢指针指向链表中点的位置
        - 将慢指针指向的位置继续遍历链表，并将数据放入栈中
        - 从头遍历链表到中点位置，并与栈中弹出的数据进行比较
        - 值都相等则为回文结构
        - 时间复杂度O(n), 空间复杂度O(n/2)
    3. **方法3**(空间复杂度最优解)
        - 使用一个快指针，一个慢指针来遍历链表，当快指针遍历完成的时候，慢指针指向链表中点的位置
        - 将中点位置之后的链表节点顺序颠倒，比如 3 -> 2 -> 1 转换为 null <- 3 <- 2 <- 1
        - 从链表的头以及链表的尾节点开始分别遍历比较，如果都相等，则为回文结构
        - 将中点位置之后的链表顺序设置为初始顺序 
- code: [Code_07_IsPalindromeList.js](Code_07_IsPalindromeList.js)

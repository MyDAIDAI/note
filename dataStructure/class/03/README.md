## 基本概念
- 栈：后入先出
- 队列：先入先出
- 哈希函数：
    - 输入长度可以无穷大但有限，输出长度固定
    - 不是随机函数，对于相同的输入内容会返回相同的输出值
    - 离散性
    - `set`与`map`
    - 操作时间复杂度 O(1)

---------------------------------------下面是一些算法题--------------------------------------

## 使用数组模拟一个大小固定的队列以及栈
- 栈的实现
    - 栈只是一个逻辑结构，可以用数组或者链表来实现
    - 思路
        1. 使用一个索引`index`来保存位置，`index`表示的是下一个数据要存储的位置
        2. 当向栈里面`push`元素的时候, 检测栈是否满，然后保存在`index`位置，`index++`
        3. 当向栈里面`pop`元素的时候，检测栈是否空，然后`index--`，并且弹出当前`index`位置的值
- 队列的实现
    - 队列只是一个逻辑结构，可以用数组或者链表来实现
    - 队列由于是从尾部进入，从头部出，实现会比栈复杂
    - 思路
        1. 使用一个变量`end`代表当前队列的尾部，在该索引位置`push`数据
        2. 使用一个变量`start`代表当前队列的头部，在该索引位置`poll`数据
        3. 当向队列里面`pop`元素的时候，判断队列是否满，然后将数据保存在`end`位置, `end++`, 判断当前`end`的值是否等于`size`, 等于则将该索引赋值为0
        4. 当从队列向外面`poll`元素的时候，取出`start`位置的值，并将`start++`，判断当前`start`的值是否等于`size`, 等于则赋值为`0`
    - 注意：头部索引`start`与尾部索引`end`不相互依赖，互相独立，根据`size`来进行相互制约（相当于`start`一直在追`end`）
- code: [Code_01_ArrayToStackQueue.js](Code_01_ArrayToStackQueue.js)
## 实现一个特殊的栈
- 描述：在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。
- 要求：
    - pop、push、getMin操作的时间复杂度都是O(1)。
    - 设计的栈类型可以使用现成的栈结构。
- 思路
    1. 有对时间复杂度的要求，那就用空间换取时间，创建两个栈
    2. 一个栈为`dataStack`数据栈，一个栈为`minStack`最小值栈
    3. 当`dataStack`与`minStack`都为空时，直接向里面`push`值
    4. 再次向`dataStack`里面`push`值的时候，拿出`minStack`顶部的值与要`push`的值比较，将其中较小的值推入
    5. 当`pop`数据的时候，`dataStack`与`minStack`同时`pop`
- 注意：要保持`dataStack`与`minStack`的同步
- code: [Code_02_GetMinStack.js](Code_02_GetMinStack.js)

## 如何仅用队列结构实现栈结构
- 思路：使用两个队列？
    1. 使用两个队列，一个数据队列，一个辅助队列
    2. 每次`push`数据的时候，保存到数据队列中
    3. 每次`pop`数据的时候，将数据队列中的值`push`到辅助队列中，剩下数据队列最后一个弹出
    4. 交换**数据队列**与**辅助队列**
## 如何仅用栈结构实现队列结构
- 思路: 使用两个栈?
    1. 使用两个栈，一个`push`栈，一个`pop`栈
    2. `push`数据的时候，向`push`栈中添加数据
    3. `poll`数据的时候，如果`pop`栈有数据则直接弹出返回，如果没有则将`push`栈中的数据**全部**放入到`pop`栈中，并从`pop`栈中弹出第一个数据
- 注意
    - 当`pop`栈不为空的时候不能向`pop`栈中添加数据
    - 每次从`push`栈向`pop`栈放数据的时候必须**全部**放完

- code: [Code_03_TwoQueueStack.js](Code_03_TwoQueueStack.js)
## 转圈打印矩阵
- 题目：给定一个整型矩阵matrix，请按照转圈的方式打印它。
    ```
    例如： 1 2 3 4 
           5 6 7 8 
           9 10 11 12 
           13 14 15 16 
        打印结果为：1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10
    ```
- 要求：额外空间复杂度为O(1)。
- 思路：
    - 打印一个矩阵边界上的数，拿到矩阵对角线上的两个坐标`[row1, col1]、[row2, col2]`
    - 当打印一行的时候，移动列坐标，当打印一列的时候，移动行坐标
    - 打印完成外圈矩阵之后，将`[row1, col1]`加1， 将`[row2, col2]`减1
    - 当`row1` > `row2`以及`col1` > `col2`时停止打印
    
## "之"字形打印矩阵
- 题目：给定一个矩阵matrix， 按照“之” 字形的方式打印这
     个矩阵， 例如： 1 2 3 4 5 6 7 8 9 10 11 12
     “之” 字形打印的结果为： 1， 2， 5， 9， 6， 3， 4， 7， 10， 11，
     8， 12
- 要求：额外空间复杂度为
- code: [Code_04_PrintMatrixSpiralOrder.js](Code_04_PrintMatrixSpiralOrder.js)

## 在行列都排好序的矩阵中找数
- 题目：给定一个有N*M的整型矩阵matrix和一个整数K，
     matrix的每一行和每一 列都是排好序的。实现一个函数，判断K
     是否在matrix中。 例如： 0 1 2 5 2 3 4 7 4
     4 4 8 5 7 7 9 如果K为7，返回true；如果K为6，返
     回false。
- 要求：时间复杂度为O(N+M)，额外空间复杂度为O(1)
- 思路：
    - 将右上角的点`(row, col)`作为基准值
    - 用基准值`matrix[row][col]`与传入值`num`进行比较
    - 基准值大于`num`，则`col--`
    - 基准值小于`num`, 则`row++`
    - 直到判断到`row === endRow`以及`col === 0`
- code: [Code_05_FindNumInSortedMatrix.js](Code_05_FindNumInSortedMatrix.js)

## 打印两个有序链表的公共部分
- 题目：给定两个有序链表的头指针head1和head2，打印两个链表的公共部分
- 思路：
    - 为第一个有序链表`head1`创建一个指针`index1`
    - 为第二个有序链表`head2`创建一个指针`index2`
    - 比较当前两个指针所指向的节点的值，值较小的指针向后移动
    - 当两个指针所指向的节点值相同时，同时移动并打印
    - 当其中的某个链表遍历完成或者两个同时遍历完成结束
- code: [Code_06_PrintCommonPart.js](Code_06_PrintCommonPart.js)

## 判断一个链表是否是回文结构
- 题目：给定一个链表的头节点head，请判断该链表是否为回文结构。 例如： 1->2->1，返回true。 1->2->2->1，返回true。15->6->15，返回true。 1->2->3，返回false。
- 思路：
    1. 方法1
        - 遍历链表并且使用一个栈将数据存储起来（栈弹出顺序为倒序）
        - 再次遍历链表，与栈中弹出的数据进行比较，如果都一样，则是回文结构
        - 时间复杂度O(n), 空间复杂度O(n)
    2. 方法2
        - 使用一个快指针，一个慢指针来遍历链表，当快指针遍历完成的时候，慢指针指向链表中点的位置
        - 将慢指针指向的位置继续遍历链表，并将数据放入栈中
        - 从头遍历链表到中点位置，并与栈中弹出的数据进行比较
        - 值都相等则为回文结构
        - 时间复杂度O(n), 空间复杂度O(n/2)
    3. **方法3**(空间复杂度最优解)
        - 使用一个快指针，一个慢指针来遍历链表，当快指针遍历完成的时候，慢指针指向链表中点的位置
        - 将中点位置之后的链表节点顺序颠倒，比如 3 -> 2 -> 1 转换为 null <- 3 <- 2 <- 1
        - 从链表的头以及链表的尾节点开始分别遍历比较，如果都相等，则为回文结构
        - 将中点位置之后的链表顺序设置为初始顺序 
- code: [Code_07_IsPalindromeList.js](Code_07_IsPalindromeList.js)

## 将单向链表按某值划分成左边小、中间相等、右边大的形式
- 题目：给定一个单向链表的头节点head，节点的值类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于pivot的节点，右部分都是值大于 pivot的节点。 除这个要求外，对调整后的节点顺序没有更多的要求。 例如：链表9->0->4->5- >1，pivot=3。 调整后链表可以是1->0->4->9->5，也可以是0->1->9->5->4。总 之，满 足左部分都是小于3的节点，中间部分都是等于3的节点（本例中这个部 分为空），右部分都是大于3的节点即可。对某部分内部的节点顺序不做 要求。
- 思路：
    - 1. 方法1
        - 取出链表中的节点放在数组中
        - 将数组按照**荷兰国旗问题**进行排序
        - 遍历数组，将其转换为链表
        - 时间复杂度O(n), 空间复杂度O(n), 稳定性：不稳定
    - 2. 方法2
        - 使用三个节点，`less`, `equal`, `more`三个来分别保存其中值
        - 遍历整个单向链表，将小于`pivot`的值放在`less`上，将等于的放在`equal`上，将大于的放在`more`上
        - 最后将`less`, `equal`, `more`连接起来，注意这里需要判断某些区域是否存在的情况
        - 时间复杂度O(n), 空间复杂度O(1)，稳定性：稳定
- code: [Code_08_SmallerEqualBigger.js](Code_08_SmallerEqualBigger.js)

## 复制含有随机指针节点的链表
- 题目：一种特殊的链表节点类描述如下：Node类中的value是节点值，next指针和正常单链表中next指针的意义 一 样，都指向下一个节点，rand指针是Node类中新增的指针，这个指 针可 能指向链表中的任意一个节点，也可能指向null。 给定一个由 Node节点类型组成的无环单链表的头节点head，请实现一个 函数完成 这个链表中所有结构的复制，并返回复制的新链表的头节点。 进阶： 不使用额外的数据结构，只用有限几个变量，且在时间复杂度为 O(N) 内完成原问题要实现的函数。
    ```
        class Node {
            constructor(val) {
                this.random = null
                this.value = val
                this.next = null
            }
        }
    ```
- 思路：
    - 1. 方法1：
        - 遍历一遍链表，使用哈希表将每个节点以及拷贝节点作为`key, value`保存起来
        - 再次遍历链表，拿到当前节点的`next`以及`random`节点，并从哈希表中取出相应节点的拷贝节点，将`node`节点分别指向拷贝节点
        - 时间复杂度：O(n), 空间复杂度：O(n)
    - 2. 方法2：
        - 遍历链表，拿到当前节点，并将其生成的拷贝节点放在当前节点后面
        - 再次遍历链表， 一次拿去两个节点，一个为原节点，一个为拷贝节点
        - 拿到原节点的`random`指针，那么拷贝节点的`random`指针就为原节点`random`指针的后一个
        - 再次遍历链表，将链表中的拷贝节点取出链接起来
        - 时间复杂度：O(n), 空间复杂度：O(n)
- code: [Code_09_CopyListWithRandom.js](Code_09_CopyListWithRandom.js)

## 两个单链表相交的一系列问题
- 题目：在本题中，单链表可能有环，也可能无环，给定两个单链表的头结点head1和head2, 这两个链表可能相交也可能不相交，请实现一个函数，请返回相交的第一个节点，如果不相交，返回null即可。要求：如果链表1的长度为n, 链表2的长度为m， 时间复杂度请达到o(n + m), 额外空间复杂度请达到o(1)
- 思路：
    - 先判断有环还是无环, 如果有环，拿到第一个入环节点
        - 判断是否有环:
            - 方法1： 遍历链表，使用哈希表将当前值保存，每次遍历的时候都判断哈希表中是否有该值，如果有，则有环，并将该值返回, 空间复杂度O(n)
            - 方法2： 使用快慢指针的方法，快指针一次走两步，慢指针一次走一步，当快慢两个指针在环上相遇，则有环， 空间复杂度O(1)
        - 拿到入环节点：在快慢指针相遇之后，将快指针置为头，快慢指针同时向前走，当快慢指针相等时的节点则为第一个入环节点
    - 两个链表都无环，可能相交，可能不相交
        - 分别拿到两个链表的长度以及尾节点，如果两个链表的尾节点相等，则相交，否则不相交
        - 如果两个链表相交，则根据两个链表的长度将长链表先走它们的长度差值的距离，然后一起走，知道两个值相等，此时的节点为相交的第一个节点
    - 两个链表一个有环，一个无环，不可能相交
    - 两个链表都有环，可能相交，可能不相交
        - 拿到两个链表的第一个入环节点，如果两个节点相等，则相交, 如果不相等，则继续在环上遍历，如果遇到另一个链表的入环节点，则相交，如果最后回到自己，则不相交
        - 如果两个入环节点相等，则跟两个无环相交的情况相似
        - 如果一个入环节点与另一个入环节点相遇，则相交节点为两个入环节点中的随意一个都行
- code: [Code_10_FindFirstIntersectNode.js](Code_10_FindFirstIntersectNode.js)

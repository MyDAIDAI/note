# 查找

## 符号表
### 顺序查找（基于无序链表）
`get()`会顺序地搜索链表查找给定的键，`put()`会顺序搜索链表查找给定的键，如果找到则更新相关的值，否则则会用给定的键值对创建一个新的结点并插入到链表的开头

在含有`N`对键值的基于（无序）链表的符号表中，查找和插入操作都需要`N`次比较

时间复杂度：`O(N)`
code: [SequentialSearchST.js](SequentialSearchST.js)

### 有序数组中的二分查找
`rank`函数的作用：
- 如果表中存在该键，`rank()`应该返回该键的位置，也就是表中小于它的键的数量
- 如果表中不存在该键，`rank()`还是应该返回表中小于它的键的数量

时间复杂度：`O(logN)`

一般情况下**二分查找**都比**顺序查找**快得多，它也是众多实际应用程序的最佳选择。对于一个**静态表**（不允许插入）来说，将其在初始化时就排序是值的的
code: [BinarySearchST.js](BinarySearchST.js)

#### 符号表的各种实现的优缺点
|  数据结构|实现  |优点  |缺点|
| --- | --- | --- | --- |
| 链表（顺序查找） | SequentialSearchST  | 适用于小型问题 | 对于大型符号表很慢 |
| 有序数组（二分查找） | BinarySearchST  | 最优的查找效率和空间需求，能够进行有序性相关的操作 | 插入操作很慢|
| 二叉查找树 | BST | 实现简单，能够进行有序性相关的操作 | 没有性能上界的保证，链接需要额外的空间 |
| 平衡二叉查找树 | RedBlackBST | 最优的查找和插入效率，能够进行有序性相关的工作 | 链接需要额外的空间 |
| 散列表 | SeparateChainHashST/LinearProbingHashST | 能够快速地查找和插入常见类型的数据 | 需要计算每种类型的数据的散列，无法进行**有序性**相关的操作，链接和空结点需要额外的空间 |


## 二叉查找树
**二叉查找树**: 每个结点都含有一个键，且每个结点的键都大于其左子树中的任意结点而小于右子树的任意结点。如果将一颗二叉查找树的所有键投影到一条直线上，保证一个结点的左子树中的键出现在它的左边，右子树中的键出现在它的右边，那么一定可以得到一个有序的键列

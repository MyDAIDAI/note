# 类型、值和变量

## 数字

`js`不区分整数值和浮点数值

### 整型直接量

- 用一个数字序列表示一个十进制数 `0 3 10000`
- 也能识别十六进制值，以`0x`或`0X`为前缀，其后跟随十六进制数串的直接量 `0xff oxCAFE911`

### 浮点型直接量

- 浮点型直接量可以含有小数点，一个实数由整数部分、小数点、小数部分组成
- 还可以用指数记数法表示
- `[digits][.digits][(E/e)[(+/-)digitis]]`
- `1.43234E-23`

### `JavaScript`中的算术运算

- 基本运算：加，减，乘，除，求余 `+  - * / %`

- 除了基本运算以外，`javaScript`还支持更加复杂的算术运算，通过`Math`对象的属性定义的函数和常量来实现

  ```javascript
  Math.pow(2, 23) // 2的23次幂
  Math.round(.6) // 四舍五入
  Math.ceil(.6)  // 向上求整
  Math.floor(.6) // 向下求整
  Math.abs(-5)   // 求绝对值
  Math.max(2, 3) // 求最大值
  Math.min(2, 3) // 求最小值
  Math.random    // 生成伪随机数
  Math.PI        // 圆周率
  Math.E         // 自然对数的底数
  ...
  ```

- 溢出、下溢或被零整除时不会报错

  - 溢出
    - 超出上限，用`Infinity`表示
    - 超出下限，用`-Infinity`表示
  - 下溢
    - 运算结果无限接近于零并比`JavaScript`能表示的最小值还小的时候
    - 返回`0`
  - 被零整除
    - 返回无穷大`Infinity`或负无穷大`-Infinity`
    - `0/0`返回`NaN`

- `NaN`

  - 与任何值都不相等，包括自身
  - 使用`x != x`，当且仅当`x`为`NaN`的时候，表达式才为`true`


### 二进制浮点数和四舍五入错误

在`javaScript`中使用实数，常常只是真实值的一个近似表示，`js`所采用的`IEEE-754`浮点表示法，是一种二进制表示法，可以精确的表示分数`1/2 1/8和 1/ 1024`，但我们常用的分数都是十进制分数`1/10 1/ 1000`，二进制浮点数表示法并不能精确表示类似`0.1`这样简单的数字

```
var x = 0.3 - 0.2
var y = 0.2 - 0.1
x == y // false
x // 0.09999999999999998
y // 0.1
```

为了避免上述错误，更愿意使用大整数进行重要的金融计算，例如，要使用整数“分”而不要使用小数“元”进行基于货币的运算

### 日期和时间

使用`Date()`构造函数，用来创建表示日期和时间的对象



## 文本

`js`字符串是由一组无符号的16位值组成的序列，代表字符串中的单个字符，那些不能表示为16位的`Unicode`字符，遵循`UTF-16`编码规则—用两个16位值组成的一个序列表示，这表示一个长度为2的字符串，有可能表示一个`Unicode`字符

### 字符串直接量

- 使用单引号时，需要注意对英文缩写和所有格进行转义，因为撇号与引号是同一个字符

### 转义字符

`\`,反斜线符号后面加一个字符，就不再表示其字面含义，常用转义字符

| 转义字符 | 含义                                 |
| -------- | ------------------------------------ |
| \b       | 退格符                               |
| \t       | 水平制表符                           |
| \n       | 换行符                               |
| \v       | 垂直制表符                           |
| \uXXXX   | 由4位十六进制数XXXX指定的Unicode字符 |

### 字符串的使用

- `+`连接字符串
- `length`确定字符串长度
- 其他方法 
  - `charAt`
  - `substring`
  - `slice`
  - `indexof`
  - `lastIndexof`
  - `split`
  - `replace`
  - `toUpperCase`
- 注意：在`javaScript`字符串是固定不变的，类似`replace()`和`toUpperCase()`的方法都是返回新字符串，原字符串本身并没有发生改变

### 模式匹配

使用`RegExp()`构造函数，用来创建表示文本匹配模式的对象，`String`和`RegExp`对象均定义了利用正则表达式进行模式匹配和查找与替换的函数

```javascript
var text = 'testing: 1, 2, 3'
var pattern = /\d+/g
pattern.test(text) // true
text.search(pattern) // 9
text.match(pattern) // ["1", "2", "3"]
text.replace(pattern, "#") // 'testing: #， #， #'
text.split(/D+/) // ["", "1", "2", "3"]
```

## 布尔值

任意`javaScript`的值都可以转换为布尔值，以下将会被转换为`false`,所有其他值，包括所有对象（数组）,包括空数组，空对象，都会转换为`true`，布尔运算符，`&&`，`||`， `!`

- `undefined`
- `null`
- `0`
- `-0`
- `NaN`
- `''`

## `null`和`undefined`

- `type null ==> 'object'`
- `type undefined ==> 'undefined'`
- 若想将它们赋值给变量或者属性，或将它们作为参数传入函数，最佳选择是使用`null`

## 全局对象

全局对象的属性是全局定义的符号，`javaScipt`程序可以直接使用，当`javaScript`解释器启动时或者浏览器重新加载页面的时候，它将创建一个新的全局对象，并给它一组定义的初始属性：

- 全局属性，比如`undefined`, `Infinity`和`NaN`
- 全局函数，比如`isNaN()`, `parseInt()`, `eval()`
- 构造函数，比如`Date()`, `RegExp()`,`String()`, `Object()`, `Array()`, `Number()`
- 全局对象，比如`Math`和`JSON`

如果代码声明了一个全局变量，这个全局变量就是全局对象的一个属性

## 包装对象

`javaScript`对象是一种复合值：它是属性或已命名值的集合。可以通过`.`符号来引用属性值，通过 `o.m()`来调用其中的方法，其实字符串也具有同样的属性和方法

```javascript
var s = 'hello world'
var word = s.substring(s.indexOf(" ") + 1, s.length)
```

字符串不是对象，但是`javaScript`会将字符串值通过调用`new String(s)`的方式转换为对象，这个对象继承了字符串的方法，并被用来处理属性的引用。一旦属性引用结束，这个新创建的对象就会被销毁，`Number（）`和`Boolean（）`同样，但是`null`和`undefined`没有包装对象，访问它们的属性会造成类型错误

```javascript
var s = "test"
s.len = 4
var t = s.len
console.log(t) // undefined
```

`javaScript`在第二行创建一个临时字符串对象，并将其`len`属性赋值为4，随即就销毁这个对象。再次访问该属性，该属性不存在，所以为`undefined`

存取字符串、数字或布尔值的属性时创建的临时对象被称做包装对象，它只是偶尔用来区分字符串值和字符串对象，数字和数值对象以及布尔值和布尔对象

需要注意的是，可通过`String()`，`Number()`, `Boolean()`构造函数类显式创建包装对象，但是会在必要的时候将包装对象转换为原始值，使用`===`和`typeof`可以检测出原始值与包装对象的不同

## 不可变的原始值和可变的对象引用

`javaScript`中的原始值(`undefined`, `null`, 布尔值，字符串和数字)与对象（数组，函数）有着根本区别

- 原始值是不可改变的，任何方法都无法更改一个原始值

  - 改变数字与布尔的值本身就说不通

  - 字符串看起来像是由字符组成的数组，我们期望可以通过指定索引来 修改字符串中的字符。但`javaScript`禁止这样做，字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值

  - ```javascript
    var s = 'hello world'
    s.toUppperCase() // HELLO WORLD
    console.log(s) // hello world
    ```

- 原始值的比较

  - 数字，布尔值，`null`和`undefined`，只有在它们的值相等的时候它们才相等
  - 字符串，当且仅当它们的长度相等且每个索引的字符都相等的时候，`javaScript`才认为它们相等

- 对象值是可变的，它们的值是可以修改的

  ```javascript
  var o = { x: 1 }
  o.x = 2
  o.y = 1
  o // {x: 2, y: 1}
  
  var a = [1, 2, 3]
  a[0] = 2
  a[3] = 4
  a // [2, 2, 3, 4]
  ```

- 对象的比较

  - 对象的比较并非值的比较，即使两个对象包含同样的属性及相同的值，它们也是不相等的

  - 各个索引元素完全相等的两个数组也不相等

    ```javascript
    var o = {x:1}
    var p = {x:1}
    o === p // false: 两个单独的对象永不相等
    var a = [1, 2, 3]
    var b = [1, 2, 3]
    a === b // false: 两个单独的数组永不相等
    ```

  - 通常将对象称为引用类型，以此来和`javaScript`的基本类型进行区分，根据术语的叫法，其对象值都是引用，对象的比较均是引用的比较，当且仅当它们引用同一个基对象时，它们才相等

  - ```javascript
    var a = [] 	// 定义一个引用空数组的变量a
    var b = a	// 变量b引用同一个数组
    b[0] = 1	// 通过变量b来修改引用的数组
    a[0] 		// 1: a变量也会修改
    a === b 	// true: a和b引用同一个数组，因此相等
    ```

    如上面的代码那样，将对象（或数组）赋值给一个变量，仅仅是赋值的引用值，对象本身并没有复制一次。若想得到对象或者数组的副本，就必须要显式复制对象的每个属性或者数组的每个元素。同样，我们想比较两个单独的对象或者数组，则必须 比较它们的属性或元素，下面的代码定义了一个比较两个数组的函数：

    ```javascript
    function equalArrays (a, b) {
    	if (a.length !== b.length) {return false} 	// 两个长度不同的数组不相等
        for (var i = 0; i < a.length; i++) {		
            if (a[i] !== b[i]) {					// 若有任意元素不相等，则数组不相等
                return false
            }
    	}
        return true
    }
    ```

## 类型转换

| 值                        | 字符串         | 数字 | 布尔值 | 对象                  |
| ------------------------- | -------------- | ---- | ------ | --------------------- |
| undefined                 | "undefined"    | NaN  | false  | throws TypeError      |
| null                      | "null"         | 0    | false  | throws TypeError      |
| true                      | "true"         | 1    |        | new Boolean(true)     |
| false                     | "false"        | 0    |        | new Boolean(false)    |
| ""                        |                | 0    | false  | new String("")        |
| "1.2"(非空，数字)         |                | 1.2  | true   | new String("1.2")     |
| "one"(非空，非数字)       |                | NaN  | true   | new String("one")     |
| 0                         | "0"            |      | false  | new Number(0)         |
| -0                        | "0"            |      | false  | new Number(-0)        |
| NaN                       | "NaN"          |      | false  | new Number(NaN )      |
| Infinity                  | "Infinity"     |      | true   | new Number(Infinity)  |
| -Infinity                 | "-Infinity"    |      | true   | new Number(-Infinity) |
| 1(无穷大，非零)           | "1"            |      | true   | new Number(1)         |
| {}(任意对象)              |                |      | true   |                       |
| [] (任意数组)             |                |      | true   |                       |
| [ 9 ] (1个数组元素)       | "9"            | 9    | true   |                       |
| ['a'] (其他数组)          | 使用join()方法 | NaN  | true   |                       |
| function () {} (任意函数) |                | NaN  | true   |                       |

- 原始值转换为数字：
  - 以数字表示的字符串可以直接转换为数字，也允许在开始和结尾处带有空格
  - 在开始与结尾处的任意非空字符都不能被当做数字直接量的一部分，会转换为`NaN`
- 原始值到对象的转换，原始值通过调用`String()`，`Number()`，`Boolean()`构造函数，转换为它们各自的包装对象
- `null`和`undefined`转换为对象会造成类型错误

### 转换和相等性

`javaScript`可以做灵活的类型转换，因此在`==`相等运算符也随相等的含义灵活多变，`===`恒等运算符在判断相等时并未做任何类型转换

注意：一个值转换为另一个值并不意味着两个值相等，比如，在使用布尔值的地方使用了`undefined`，它将会转换为`false`，但并不意味着`undefined == false`, `==`运算符从不试图将其操作数转换为布尔值

### 显式类型转换

使用`Boolean()`，`Number()`，`String()`，`Object()`来显式的进行类型转换，当不通过`new`运算符调用这些函数的时候，它们会作为类型转换函数进行转换:

```javascript
Number("3") // 3
String(false) // "false"
Boolean([]) // true
Object(3) // new Number(3)
```

- 除了`null`和`undefined`之外的任何值都具有`toString()`方法，这个方法的执行结果与`String()`方法一致

- 若将`null`和`undefined`转换为对象，会抛出类型错误

- 某些运算符会做隐式类型转换，下面是一些类型转换的惯用法：

  - `+`运算符的一个操作数是字符串，那么会将另一个操作数也转为字符串

  - 一元`+`运算符将其操作符转换为数字

  - 一元`!`运算符将其操作数转为为布尔值并取反

    ```javascript
    x + "" // 数字转为字符串，等价于String(x)
    +x 	   // 字符串转为数字，等价于Number(x)
    !!x    // 转换为布尔值，等价于Boolean(x)
    ```

- `javaScript`提供了专门的函数与方法用来做更加精确的数字到字符串和字符串到数字的转换

  - 数字 --> 字符串

    - `toString()`：可以接受转换基数作为参数，不指定，则转换基于十进制，注意，转换前数字的基数都是基于十进制，参数代表的是转换之后的基数

      ```javascript
      var n = 17;
      binary_string = n.toString(2) // "10001"
      octal_string = "0" + n.toString(8) // "021"
      hex_string = "0x" + n.toString(16) // "0x11"
      ```

    - `toFixed()`：根据小数点后的指定位数将数字转换 为字符串，它从不使用指数计数法

    - `toExponential()`：使用指数记数法将数字转换为指数形式的字符串，其中小数点前只有一位，小数点后的位数则由参数指定

    - `toPrecision()`：根据指定的有效数字位数将数字转换为字符串，如果有效数字的位数少于数字整数部分的位数，则转换为指数形式

      ```javascript
      var n = 123456.789
      n.toFixed(0)
      "123457"
      n.toFixed(1)
      "123456.8"
      n.toFixed(2)
      "123456.79"
      n.toExponential(0)
      "1e+5"
      n.toExponential(1)
      "1.2e+5"
      n.toExponential(2)
      "1.23e+5"
      n.toExponential(3)
      "1.235e+5"
      n.toExponential(4)
      "1.2346e+5"
      n.toPrecision(3)
      "1.23e+5"
      n.toPrecision(10)
      "123456.7890"
      ```

  - 字符串 --> 数字

    - 通过`Number()`转换函数将字符串转换为数字，只能基于十进制数进行转换，并且不能出现非法的尾随字符，但`parseInt()`和`parseFloat()`更加灵活，都会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容

    - `parseInt()`：只解析整数，字符串前缀为`0x`或者是`0X`，会将其解释为十六进制

    - `parseFloat()`：可以解析整数和浮点数

      ```javascript
      parseInt('3 bilind mics')
      3
      parseInt(" 3.14 ")
      3
      parseInt(" -12.34 ")
      -12
      parseInt("0Xff")
      255
      parseInt("-0xff")
      -255
      parseFloat(".1")
      0.1
      parseInt("0.1")
      0
      parseInt(".1")
      NaN 整数不能以"."开始
      parseFloat("$92.1")
      NaN 数字不能以"$"开头
      ```

    - `parseInt()`（没有`parseFloat`）可以接收第二个可选参数，这个参数指定数字转换的基数

      ```javascript
      parseInt('11', 2)
      3
      parseFloat('11.11', 2)
      11.11
      parseInt("FF", 16)
      255
      ```

      注意：上面的基数是转换之前字符串所代表的基数，最后都将其转换为十进制，无论是使用`toString()`将数字转换为字符串，还是使用`parseInt()`将字符串转换为数字，其中的数字都是十进制，基数参数都是字符串的基数，`toString`中的基数参数代表的是转换之后的字符串的基数，`parseInt`代表的是转换前字符串的基数
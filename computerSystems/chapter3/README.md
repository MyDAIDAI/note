# 程序的机器级表示
计算机执行**机器代码**，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信

GCC C语言编译器以**汇编代码**的形式产生输出,**汇编代码**是机器代码的文本表示，给出程序中的每一条指令, 然后GCC调用**汇编器**和**链接器**，根据汇编代码生成可执行的机器代码

用高级语言编写的程序可以在很多不同的机器上编译和执行，而汇编代码则是与特定机器密切相关的

## 程序编码
```
gcc -Og -o p p1.c p2.c
```
上面是一条编译c程序文件的指令，编译选项`-Og`告诉编译器使用会生产符合原始`C`代码整体结构的机器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。实际上，从得到的程序的性能考虑，较高级别的优化，例如`-O1`， `-O2`被认为是较好的选择

C预处理器扩展源代

```flow
st=>start: 开始

op1=>operation: 扩展源代码，插入所有用#include命令指定的文件，并扩展所有用#define声明指定的宏
op2=>operation: 编译器产生源文件的汇编代码
op3=>operation: 汇编器会将汇编代码转化为二进制目标代码文件
op4=>operation: 链接器将目标代码问价与实现库函数(printf)代码合并，生产最终可执行代码文件
e=>end: 结束
st->op1->op2->op3->op4->e

```

- 目标代码：目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址，所有后面会有最后一步**链接**操作

### 机器级代码

对于机器级编程来说，其中两种抽象尤为重要

- 由**指令集体系结构或指令级架构**来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式、以及每条指令对状态的影响
- 机器级程序使用的内存地址是**虚拟地址**，提供的内存模型看上去是一个非常大的字节数组

-----------------

X86-64的机器代码和原始的C代码差别非常大。一些通常对C语言程序员隐藏的处理器状态都是可见的

- **程序计数器PC**：在`x86-64`中用`%rip`表示，给出将要执行的下一条指令在内存中的地址
- 整数寄存器：包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他寄存器用来保存临时数据。例如过程的参数和局部变量，以及函数的返回值
- 条件码寄存器：保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如用来实现`if`和`while`语句
- 向量寄存器：一组向量寄存器可以存放一个或多个整数或浮点数值

虽然C语言可以在内存中声明和分配各种数据类型对象，但是机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。C语言中的聚合数据类型，例如数组和数据结构，在机器代码中用一组连续的字节表示。即使是对标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分指针和整数

------------

程序内存包含：

- 程序的可执行代码
- 操作系统信息
- 管理过程调用和返回的运行时栈
- 用户分配的内存块（用`malloc`库函数分配的）

程序内存用**虚拟地址**来寻址。在任意给定的时刻，只有有限的一部分虚拟地址被认为是合法的。操作系统负责管理虚拟地址控件，将**虚拟地址翻译成实际处理器内存中的物理地址**

下面是一段C语言代码`mstore.c`
```c
long mult2(long, long);

void multstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
```
执行`gcc -Og -S mstore.c`将其转变为汇编代码，这段代码已经除去了所有关于局部变量名或数据类型的信息
```
_multstore:                             ## @multstore
	.cfi_startproc
## %bb.0:
	pushq	%rbp  ## 将寄存器%rbp的内容压入栈中
	movq	%rsp, %rbp
	pushq	%rbx
	pushq	%rax
	movq	%rdx, %rbx
	callq	_mult2 ## 调用_mult2函数
	movq	%rax, (%rbx)
	addq	$8, %rsp
	popq	%rbx
	popq	%rbp
	retq
                                        ## -- End function
```
使用`gcc -Og -c mstore.c`，编译器会编译并汇编该代码，会产生目标文件`mstore.o`.里面有一段序列就是上面所列出的汇编指令对应的目标代码。由此可得，机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码一无所知

------------------------
**反汇编器**：查看机器代码文件的内容，会根据机器代码产生一种类似于汇编代码的格式`objdump -d mstore.o`, 结果如下:
```
$ objdump -d mstore.o 

mstore.o:	file format Mach-O 64-bit x86-64


Disassembly of section __TEXT,__text:

0000000000000000 _multstore:
       0: 55                           	pushq	%rbp
       1: 48 89 e5                     	movq	%rsp, %rbp
       4: 53                           	pushq	%rbx
       5: 50                           	pushq	%rax
       6: 48 89 d3                     	movq	%rdx, %rbx
       9: e8 00 00 00 00               	callq	0 <_multstore+0xe>
       e: 48 89 03                     	movq	%rax, (%rbx)
      11: 48 83 c4 08                  	addq	$8, %rsp
      15: 5b                           	popq	%rbx
      16: 5d                           	popq	%rbp
      17: c3                           	retq
```
左边是二进制指令，右边是对应的汇编语言